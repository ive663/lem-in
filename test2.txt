// + A room will never start with the letter L or with # and must have no spaces.
// - too many? How many?
package main
import (
	"bufio"
	"fmt"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
)
type Room struct {
	Name    string
	X       int
	Y       int
	Visited bool
	Links   []string
}
type Path struct {
	Length int
	Dist   []string
}
type FPath struct {
	FLength int
	FDist   []string
}
type Step struct {
	AIndex int
	RName  string
}
var rooms []Room
var paths []Path
var finalpaths []FPath


func main() {
	args := os.Args[1:]
	if len(args) != 1 {
		fmt.Println("Please pass an input file")
		os.Exit(0)
	}
	filename := args[0] //obtaining farm's filename from os.Args
	file, err := os.Open(filename) //banner file
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file) //scanner to read the input file
	counter := 0        //needed to find antNum
	roomIdentifier := 0 //if 1 -> start room, if 2 -> end room, else -> usual room
	antNum := 0         //# of ants
	startRoom, endRoom, startFound, endFound := "", "", false, false


	
	//var rooms []Room                           //slice of all rooms
	for scanner.Scan() { //scanning the file line by line
		if counter == 0 { //finding antNum
			antNum, err = strconv.Atoi(scanner.Text())
			if err != nil || antNum <= 0 {
				fmt.Println("ERROR: invalid data format1")
				return
			}
			counter++
			continue
		}
		inputLine := scanner.Text() //Reading a line
		if inputLine == "" {
			counter++
			continue
		}
		if inputLine == "##start" { //Catching start room
			roomIdentifier = 1
			counter++
			continue
		} else if inputLine == "##end" { //Catching end room
			roomIdentifier = 2
			counter++
			continue
		} else { //Other rooms
			if (roomIdentifier == 1 && startFound == false) || (roomIdentifier == 2 && endFound == false) {
			} else {
				roomIdentifier = 0
			}
		}
		input := strings.Split(inputLine, " ")
		//fmt.Println(input)
		if len(input) == 3 {
			roomName := input[0]
			if roomName[:1] == "#" || roomName[:1] == "L" { //Checking 'L' and '#' in the beginning of a room name
				fmt.Println("ERROR: invalid data format57")
				return
			}
			if roomIdentifier == 1 { //StartRoom found
				startRoom, startFound = input[0], true
			} else if roomIdentifier == 2 { //EndRoom found
				endRoom, endFound = input[0], true
			}
			AddRoom(input) //Adding the room to rooms slice
		} else if len(input) == 1 {
			link := strings.Split(input[0], "-")
			if len(link) != 2 {
				//fmt.Println("ERROR: invalid data format2")
				counter++
				continue
			}
			if link[0] == link[1] {
				fmt.Println("ERROR: invalid data format13")
				return
			}
			if !(ThereIsRoom(link[0]) && ThereIsRoom(link[1])) {
				fmt.Println("ERROR: invalid data format157")
				return
			}
			for x := range rooms {
				if rooms[x].Name == link[0] && !Contains(link[0], link[1]) {
					rooms[x].Links = append(rooms[x].Links, link[1])
				}
				/*if rooms[x].Name == link[1] && !Contains(link[1], link[0]) {
					rooms[x].Links = append(rooms[x].Links, link[0])
				}*/
			}
		}
		counter++
	}
	if !(startFound && endFound) { //If no start or no end
		fmt.Println("ERROR: invalid data format5")
		return
	}
	fmt.Println(antNum)
	fmt.Println("StartRoom: ", startRoom)
	fmt.Println("EndRoom: ", endRoom)
	for be := range rooms {
		fmt.Println(rooms[be])
	}
	if startRoom == endRoom {
		fmt.Println("Start room and End room are the same, try different input")
		os.Exit(0)
	}
	PrintAllPaths(startRoom, endRoom)
	PrintShortestPath()
	AntsAllocation(antNum)
	os.Exit(0)
}



func PrintAllPaths(startRoom, endRoom string) {
	isVisited := make(map[string]bool)
	for x := range rooms {
		isVisited[rooms[x].Name] = false
	}
	pathList := []string{startRoom}
	PrintAllPathsUtil(startRoom, endRoom, isVisited, pathList)
}
func GetLinks(s string) []string {
	for x := range rooms {
		if s == rooms[x].Name {
			return rooms[x].Links
		}
	}
	return nil
}
func Remove(pathList []string, x string) []string {
	var res []string
	for k := range pathList {
		if x != pathList[k] {
			res = append(res, pathList[k])
		}
	}
	return res
}
func PrintAllPathsUtil(s, d string, isVisited map[string]bool, pathList []string) {
	isVisited[s] = true
	if s == d {
		fmt.Println(pathList, len(pathList))
		paths = append(paths, Path{Dist: pathList, Length: len(pathList)}) // saving all path to struct
		isVisited[s] = false
		return
	}
	for _, x := range GetLinks(s) {
		if !isVisited[x] {
			pathList = append(pathList, x)
			PrintAllPathsUtil(x, d, isVisited, pathList)
			pathList = Remove(pathList, x)
		}
		isVisited[s] = false
	}
}
func Contains(room1, room2 string) bool { //checks if a room2 is in links of room1
	for x := range rooms {
		if rooms[x].Name == room1 {
			for _, i := range rooms[x].Links {
				if i == room2 {
					return true
				}
			}
		}
	}
	return false
}
func AddRoom(input []string) { //Adds room to rooms slice
	for x := range rooms {
		if rooms[x].Name == input[0] {
			fmt.Println("ERROR: invalid data format6")
			return
		}
	}
	x, err := strconv.Atoi(input[1])
	if err != nil || x < 0 {
		fmt.Println("ERROR: invalid data format7")
		return
	}
	y, err := strconv.Atoi(input[2])
	if err != nil || y < 0 {
		fmt.Println("ERROR: invalid data format8")
		return
	}
	rooms = append(rooms, Room{Name: input[0], X: x, Y: y})
}
func ThereIsRoom(s1 string) bool { //Checks the existence of such room
	for x := range rooms {
		if rooms[x].Name == s1 {
			return true
		}
	}
	return false
}
func PrintShortestPath() { //prints shortest paths
	fmt.Println("-----------------")
	for x := range paths {
		fmt.Println(paths[x])
	}
	fmt.Println("-----------------")
	sort.SliceStable(paths, func(i, j int) bool { // sorting struct by length
		return paths[i].Length < paths[j].Length
	})
	fmt.Println(paths)
	fmt.Println("-----------------")
	finalpaths = append(finalpaths, FPath{FDist: paths[0].Dist, FLength: paths[0].Length})
	for _, x := range paths { // checking for overlap
		overlapchecker := false
		for i := 1; i < x.Length-1; i++ {
			for _, y := range finalpaths {
				for j := 1; j < y.FLength-1; j++ {
					if x.Dist[i] == y.FDist[j] {
						overlapchecker = true
					}
				}
			}
		}
		if !overlapchecker {
			finalpaths = append(finalpaths, FPath{FDist: x.Dist, FLength: x.Length})
		}
	}
	fmt.Println("-------bla----------")
	for x := range finalpaths {
		fmt.Println(finalpaths[x])
	}
}
func AntsAllocation(antNum int) {
	var roomsants1 []int
	var roomsants2 []int
	for _, x := range finalpaths {
		roomsants1 = append(roomsants1, x.FLength-2)
		roomsants2 = append(roomsants2, x.FLength-2)
	}
	i := 0
	for antNum > 0 {
		if i == len(roomsants2)-1 {
			i = 0
		}
		if roomsants2[i] <= roomsants2[i+1] {
			roomsants2[0]++
			antNum--
			if !AntNumChecker(antNum) {
				break
			}
			i = 0
		} else {
			roomsants2[i+1]++
			antNum--
			if !AntNumChecker(antNum) {
				break
			}
			i++
		}
	}
	fmt.Println(roomsants1)
	fmt.Println(roomsants2)
	MoveAnts(roomsants1, roomsants2)
}
func AntNumChecker(antNum int) bool {
	if antNum <= 0 {
		return false
	} else {
		return true
	}
}
func MoveAnts(roomsants1 []int, roomsants2 []int) {
	fmt.Println("-----ants--------")
	Print3D(roomsants1, roomsants2)
}
func Create3D(roomsants1 []int, roomsants2 []int) [][][]*Step {
	result := make([][][]*Step, len(roomsants2))
	ant := 0
	for i := 0; i < len(roomsants2); i++ {
		result[i] = make([][]*Step, roomsants2[i])
		for j := 0; j < roomsants2[i]; j++ {
			result[i][j] = make([]*Step, roomsants2[i]-roomsants1[i])
			for k := 0; k < roomsants2[i]-roomsants1[i]; k++ {
				result[i][j][k] = new(Step)
				result[i][j][k].AIndex = k + 1 + ant
				result[i][j][k].RName = "nil"
			}
		}
		ant = ant + roomsants2[i] - roomsants1[i]
	}
	return result
}
func Fill3D(roomsants1 []int, roomsants2 []int) [][][]*Step {
	mat := Create3D(roomsants1, roomsants2)
	for i := 0; i < len(roomsants2); i++ {
		for j := 0; j < roomsants2[i]; j++ {
			for k := 0; k < roomsants2[i]-roomsants1[i]; k++ {
				if j+1-k < finalpaths[i].FLength && j+1 > k {
					mat[i][j][k].RName = finalpaths[i].FDist[j+1-k]
				}
			}
		}
	}
	return mat
}
func Print3D(roomsants1 []int, roomsants2 []int) {
	mat := Fill3D(roomsants1, roomsants2)
	for i := 0; i < FindMax(roomsants2); i++ {
		for j := 0; j < len(roomsants2); j++ {
			for k := 0; k < roomsants2[j]-roomsants1[j]; k++ {
				if mat[j][i][k].RName != "nil" && roomsants2[j] <= FindMax(roomsants2) {
					fmt.Print("L", mat[j][i][k].AIndex, "-", mat[j][i][k].RName, " ")
				}
			}
		}
		fmt.Println()
	}
}
func FindMax(roomsants2 []int) int {
	max := roomsants2[0]
	for i := 1; i < len(roomsants2); i++ {
		if roomsants2[i] > max {
			max = roomsants2[i]
		}
	}
	return max
}
